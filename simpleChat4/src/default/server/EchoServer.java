package server;import java.io.*;import java.util.Observable;import java.util.Observer;import client.CommandTable;import common.ChatIF;import ocsf.server.*;/** * This class overrides some of the methods in the abstract superclass in order * to give more functionality to the server. *  * @author Emmanuelle Ithier * @author Yannick Paz * @version 17 jan 2013 */public class EchoServer implements Observer {	// Class variables *************************************************	/**	 * The default port to listen on.	 */	final public static int DEFAULT_PORT = 5555;	ChatIF serverUI;	int port;	ObservableOriginatorServer obs;	// Constructors ****************************************************	// Construit l'instance d'EchoServer	// initialise l'observable	// et s'inscrit a la liste de ses observateurs	public EchoServer(int port, ChatIF ui) {		this.port = port;		serverUI = ui;		this.obs = new ObservableOriginatorServer(this.port);		obs.addObserver(this);	}	// Instance methods ************************************************	/**	 * This method handles any messages received from the client.	 * 	 * @param msg	 *            The message received from the client.	 * @param client	 *            The connection from which the message originated.	 */	public void handleMessageFromClient(Object msg, ConnectionToClient client) {		if (((String) msg).startsWith(CommandServer.login)) {			String id = ((String) msg).substring(7);			if (client.getInfo("login") == null) {				client.setInfo("login", id);			} else {				try {					client.sendToClient("You have already a login");				} catch (IOException e) {					e.printStackTrace();				}			}		} else if (((String) msg).startsWith(CommandServer.logoff)) {			try {				client.close();			} catch (IOException e) {				e.printStackTrace();			}		} else if (client.getInfo("login") != null) {			// Lorsqu'on recoit un message d'un utilisateur enregistrer			// (comprendre, avec login), on affiche le message recu accompagne			// du login du client. Ensuite, on l'envoie a tous les clients.			this.serverUI.display("Message received: " + msg + " from "					+ client.getInfo("login"));			this.sendToAllClients(msg);		} else {			try {				client.sendToClient("You do not have a login");			} catch (IOException e) {				e.printStackTrace();			}		}	}	// Delegue l'envoie a tous les clients a l'observateur.	public void sendToAllClients(Object msg) {		obs.sendToAllClients(msg);	}	// Traite les messages en provenance de l'interface utilisateur.	public void handleMessageFromServerUI(String message) {		// Lorsqu'on souhaite quitter le serveur, on ferme d'abord celui-ci.		if (message.startsWith(CommandServer.quit)) {			try {				this.close();			} catch (IOException e) {				e.printStackTrace();			}			// Puis on arrete l'execution.			System.exit(0);		} else if (message.startsWith(CommandServer.stop)) {			this.stopListening();		} else if (message.startsWith(CommandServer.start)				&& !this.isListening()) {			try {				this.listen();			} catch (IOException e) {				e.printStackTrace();			}		} else if (message.startsWith(CommandServer.start)				&& this.isListening()) {			this.serverUI.display("Server is already listening");		} else if (message.startsWith(CommandServer.close)) {			try {				this.close();			} catch (IOException e) {				e.printStackTrace();			}		} else if (message.startsWith(CommandServer.setPort)) {			try {				this.close();			} catch (IOException e) {				e.printStackTrace();			}			this.setPort(Integer.parseInt(message.substring(9)));			this.serverUI.display("The port has changed. The new port is : "					+ this.getPort());		} else if (message.startsWith(CommandServer.getPort)) {			serverUI.display(String.valueOf(this.getPort()));		} else {			// Lorsque le message de l'interface utilisateur ne contient aucune			// commande, on envoie celui-ci a tous les clients avec un prefixe.			this.sendToAllClients("Server MSG>" + message);		}	}	// =======================================================================>	// =======================================================================>	// Les méthodes suivantes deleguent le travail a l'observateur, d'ou les	// fleches indiquant le sens de la delegation (par rapport au diagramme	// fourni en tp).	private void setPort(int parseInt) {		obs.setPort(parseInt);	}	private void close() throws IOException {		this.sendToAllClients(CommandTable.logoff);		obs.close();	}	private void listen() throws IOException {		obs.listen();	}	private boolean isListening() {		return obs.isListening();	}	private void stopListening() {		obs.stopListening();	}	private int getPort() {		return obs.getPort();	}	// =======================================================================>	// =======================================================================>	/**	 * This method overrides the one in the superclass. Called when the server	 * starts listening for connections.	 */	protected void serverStarted() {		System.out.println("Server listening for connections on port "				+ getPort());	}	/**	 * This method overrides the one in the superclass. Called when the server	 * stops listening for connections.	 */	protected void serverStopped() {		System.out.println("Server has stopped listening for connections.");	}	/**	 * Hook method called each time a new client connection is accepted. The	 * default implementation does nothing.	 * 	 * @param client	 *            the connection connected to the client.	 */	protected void clientConnected(ConnectionToClient client) {		System.out.println("Un client vient de se connecter");	}	/**	 * Hook method called each time a client disconnects. The default	 * implementation does nothing. The method may be overridden by subclasses	 * but should remains synchronized.	 * 	 * @param client	 *            the connection with the client.	 */	synchronized protected void clientDisconnected(ConnectionToClient client) {		System.out.println("Un client vient de se deconnecter normalement");	}	/**	 * Hook method called each time an exception is thrown in a	 * ConnectionToClient thread. The method may be overridden by subclasses but	 * should remains synchronized.	 * 	 * @param client	 *            the client that raised the exception.	 * @param Throwable	 *            the exception thrown.	 */	synchronized protected void clientException(ConnectionToClient client,			Object argDecapsule) {		System.out.println("Un client s'est deconnecte sans dire au revoir !");	}	// dispatche les objects reçus par l'observable	public void update(Observable o, Object arg) {		// desencapsule l'objet reçu		ConnectionToClient clientDecapsule = null;		Object argDecapsule = null;		clientDecapsule = (ConnectionToClient) ((OriginatorMessage) arg)				.getOriginator();		argDecapsule = ((OriginatorMessage) arg).getMessage();		// determine le type d'objet reçu		// si c'est une exception		if (argDecapsule instanceof Exception) {			// on envoie l'argument a clientException			this.clientException(clientDecapsule, (Throwable) argDecapsule);		} else {			// sinon, c'est un message			// on verifie s'il est envoye par le serveur			// lorsqu'un client se connecte			if (((String) argDecapsule)					.startsWith(ObservableServer.CLIENT_CONNECTED)) {				this.clientConnected(clientDecapsule);			}			// lorsqu'un client se deconnecte			else if (((String) argDecapsule)					.startsWith(ObservableServer.CLIENT_DISCONNECTED)) {				this.clientDisconnected(clientDecapsule);			}			// s'il y a une exception chez un client			else if (((String) argDecapsule)					.startsWith(ObservableServer.CLIENT_EXCEPTION)) {				this.clientException(clientDecapsule, argDecapsule);			}			// s'il y a un probleme d'ecoute			else if (((String) argDecapsule)					.startsWith(ObservableServer.LISTENING_EXCEPTION)) {				this.listeningException();			}			// lorsque le serveur se ferme			else if (((String) argDecapsule)					.startsWith(ObservableServer.SERVER_CLOSED)) {				this.serverClosed();			}			// lorsque le serveur demarre			else if (((String) argDecapsule)					.startsWith(ObservableServer.SERVER_STARTED)) {				this.serverStarted();			}			// lorsque le serveur s'arrete			else if (((String) argDecapsule)					.startsWith(ObservableServer.SERVER_STOPPED)) {				this.serverStopped();			} else {				// sinon, on l'envoie a handleMessageFromClient				this.handleMessageFromClient(argDecapsule, clientDecapsule);			}		}	}	private void serverClosed() {		System.out.println("server closed");	}	private void listeningException() {		System.out.println("probleme d'ecoute");	}}