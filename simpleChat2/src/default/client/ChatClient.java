// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com package client;import ocsf.client.*;import common.*;import java.io.*;/** * This class overrides some of the methods defined in the abstract superclass * in order to give more functionality to the client. *  * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave; * @author Fran&ccedil;ois B&eacute;langer * @version July 2000 */public class ChatClient extends AbstractClient {	// Instance variables **********************************************	/**	 * The interface type variable. It allows the implementation of the display	 * method in the client.	 */	ChatIF clientUI;	String id;	// Constructors ****************************************************	/**	 * Constructs an instance of the chat client.	 * 	 * @param host	 *            The server to connect to.	 * @param port	 *            The port number to connect on.	 * @param clientUI	 *            The interface type variable.	 */	public ChatClient(String host, int port, ChatIF clientUI, String identifiant)			throws IOException {		super(host, port); // Call the superclass constructor		this.clientUI = clientUI;		this.id = identifiant;	}	// Instance methods ************************************************	/**	 * This method handles all data that comes in from the server.	 * 	 * @param msg	 *            The message from the server.	 */	public void handleMessageFromServer(Object msg) {		clientUI.display(msg.toString());	}	/**	 * This method handles all data coming from the UI	 * 	 * @param message	 *            The message from the UI.	 * @throws IOException	 */	public void handleMessageFromClientUI(String message) throws IOException {		try {			if (message.startsWith(CommandTable.quit) && this.isConnected()) {				this.quit();			} else if (message.startsWith(CommandTable.quit)					&& !this.isConnected()) {				System.exit(0);			} else if (message.startsWith(CommandTable.logoff)					&& this.isConnected()) {				sendToServer(message);				this.closeConnection();			} else if (message.startsWith(CommandTable.logoff)					&& !this.isConnected()) {				clientUI.display("You are already disconnected");			} else if (message.startsWith(CommandTable.login)					&& !this.isConnected()) {				this.openConnection();				sendToServer(message);			} else if (message.startsWith(CommandTable.login)					&& this.isConnected()) {				clientUI.display("You are already connected");			} else if (message.startsWith(CommandTable.getPort)) {				clientUI.display(String.valueOf(this.getPort()));			} else if (message.startsWith(CommandTable.setPort)					&& !this.isConnected()) {				this.setPort(Integer.parseInt(message.substring(9)));			} else if (message.startsWith(CommandTable.setPort)					&& this.isConnected()) {				clientUI.display("You are already connected. The port can not be changed");			} else if (message.startsWith(CommandTable.getHost)) {				clientUI.display(String.valueOf(this.getHost()));			} else if (message.startsWith(CommandTable.setHost)					&& !this.isConnected()) {				this.setHost(message.substring(9));			} else if (message.startsWith(CommandTable.setHost)					&& this.isConnected()) {				clientUI.display("You are already connected. The host can not be changed");			} else if (this.isConnected()) {				sendToServer(message);			} else {				clientUI.display("You need to enter your login to be connected to the chat. Please use the command : #login <login>");			}		} catch (IOException e) {			clientUI.display("Could not send message to server.  Terminating client.");			quit();		}	}	/**	 * This method terminates the client.	 */	public void quit() {		try {			closeConnection();		} catch (IOException e) {		}		System.exit(0);	}	/**	 * Hook method called after the connection has been closed. The default	 * implementation does nothing. The method may be overridden by subclasses	 * to perform special processing such as cleaning up and terminating, or	 * attempting to reconnect.	 */	protected void connectionClosed() {		System.out.println("connexion fermee, au revoir !");	}	/**	 * Hook method called each time an exception is thrown by the client's	 * thread that is waiting for messages from the server. The method may be	 * overridden by subclasses.	 * 	 * @param exception	 *            the exception raised.	 */	protected void connectionException(Exception exception) {		System.out.println("il est mort jim !");		System.out.println("le serveur n'est plus disponible, deconnexion...");		quit();	}//	la connexion est etablie, le client envoie le message//	#login <loginid>	protected void connectionEstablished() {		try {			sendToServer("#login " + this.id);		} catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}	}}// End of ChatClient class